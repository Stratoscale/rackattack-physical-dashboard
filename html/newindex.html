{% extends "base.html" %}

{% block head %}

<script>
</script>

{% block head_more %}
<link href="/static/style.css" rel="stylesheet">
<link href="/static/darktheme.css" rel="stylesheet" id="dark">
<link href="/static/lighttheme.css" rel="stylesheet" id="light">
<script src="https://unpkg.com/react@15.3.2/dist/react.js"></script>
<script src="https://unpkg.com/react-dom@15.3.2/dist/react-dom.js"></script>
<script src="https://unpkg.com/babel-core@5.8.38/browser.min.js"></script>
<script src="https://unpkg.com/remarkable@1.6.2/dist/remarkable.min.js"></script>
<script type="text/javascript" src="/realtimewebui/js/realtimewebui.js"></script>
<script type="text/javascript" src="/realtimewebui/externals/underscore-min.js"></script>
<script>
var globalModelWebsocketPort = {{globalModelWebsocketPort}};
var globalModelWebsocketSecret = "{{globalModelWebsocketSecret}}";
</script>
{% endblock %}

<script type="text/babel">
var nrHostsPerRow = 2;

var rackattackInstances = [
{% for dashboardSource in dashboardSources %}
{name: "{{ dashboardSource.name }}", host: "{{ dashboardSource.host }}"},
{% endfor %}
]
var activeDashboardName = "";
var activeDashboardHost = "";
var ui = new RealTimeWebUI();

function pad(str) {
    str = str.toString();
    var pad = "00"
    var ans = pad.substring(0, pad.length - str.length) + str
    return ans;
}

var DashboardContent = React.createClass({
  render: function() {
    return (
      <div className="row">
        <div className="col-md-6">
          <RackList hosts={this.props.hosts} />
        </div>
        <div className="col-md-6">
          allocations
        </div>
      </div>
    );
  },

});

var RackList = React.createClass({
  getRacksToHosts: function(hosts) {
    return _.groupBy(hosts, function(host) {
      var rackNumber = parseInt(host.id.replace("rack", "").replace("-server\d", ""));
      return rackNumber;
    });
  },

  getNrSlotsInASingleRack: function(racksToHosts) {
    var nrHostsPerRack = _.map(_.values(racksToHosts), function(hosts) {
      return hosts.length;
    });
    return _.max(nrHostsPerRack);
  },

  getOrderedRacks: function(hosts) {
    var racksToHosts = this.getRacksToHosts(hosts);
    var racksNumbers = Object.keys(racksToHosts);
    var orderedRacksIDs = _.sortBy(racksNumbers, function(number) {
        return number;
    });
    var nrSlots = this.getNrSlotsInASingleRack(racksToHosts);
    return _.map(orderedRacksIDs, function(rackID) {
        return (
            <Rack id={rackID} key={rackID} hosts={racksToHosts[rackID]} nrSlots={nrSlots} />
        );
    });
  },

  render: function() {
	var racks = this.getOrderedRacks(this.props.hosts);
    return (
      <div className="rackList">
        {racks}
      </div>
    );
  }
});

var Rack = React.createClass({
  getRackRows: function(hosts) {
    hosts = _.indexBy(hosts, "id");
    var nrRows = Math.ceil(this.props.nrSlots / nrHostsPerRow);
    var rackID = "rack" + pad(this.props.id);
    var rows = _.map(_.range(nrRows), function(rowNumber) {
        var idxOfFirstHostInRow = 1 + rowNumber * nrHostsPerRow;
        var rowHostsIndices = _.range(idxOfFirstHostInRow, idxOfFirstHostInRow + nrHostsPerRow);
        var rowHosts = _.map(rowHostsIndices, function(hostIdx) {
            var hostID = rackID + "-server" + pad(hostIdx);
            if (hostID in hosts) {
                return <Host data={hosts[hostID]} key={hostID} hostIdx={hostIdx} />
            }
            return <EmptyHostSlot hostID={hostID} key={hostID} hostIdx={hostIdx} />
        });
        return <RackRow key={idxOfFirstHostInRow} hosts={rowHosts} />
    });
    return rows;
  },
  render: function() {
    var rackRows = this.getRackRows(this.props.hosts);
    return (
      <div className="rack col-md-4">
        <h2>
          Rack {this.props.id}
        </h2>
        <table className="rack-table">
          <tbody>
            {rackRows}
          </tbody>
        </table>
      </div>
    );
  }
});

var RackRow = React.createClass({
  render: function() {
    return (
      <tr className="rackRow">
       {this.props.hosts}
      </tr>
    );
  }
});

var stateMap = {
    "QUICK_RECLAIMATION_IN_PROGRESS":{ iconClass: "glyphicon-backward", labelClass: "label-info" },
    "SLOW_RECLAIMATION_IN_PROGRESS":{ iconClass: "glyphicon-fast-backward", labelClass: "label-warning" },
    "CHECKED_IN":{ iconClass: "glyphicon-pause", labelClass: "label-primary" },
    "INAUGURATION_LABEL_PROVIDED":{ iconClass: "glyphicon-play", labelClass: "label-info" },
    "INAUGURATION_DONE":{ iconClass: "glyphicon-ok", labelClass: "label-success" },
    "DESTROYED":{ iconClass: "glyphicon-remove", labelClass: "label-danger" },
    "OFFLINE":{ iconClass: "glyphicon-off", labelClass: "label-default-dark" },
    "DETACHED":{ iconClass: "glyphicon-eject", labelClass: "label-detached" }
};
var NAT_ADDR = "rackattack-nat.dc1";

var Host = React.createClass({
  getNatPortFromInnerIPAddress: function(ipAddress) {
        return 2000 + parseInt(ipAddress.split(".")[3]) + (parseInt(ipAddress.split(".")[2]) - 1) * 256;
  },
  generatePopoverContent: function() {
    var content = "Inner: " + this.props.data.ipAddress;
    content += "<br />Outer: " + NAT_ADDR + ":" + this.getNatPortFromInnerIPAddress(this.props.data.ipAddress);
    if (this.props.data.nodeName) {
        content += "<br />Node: " + this.props.data.nodeName;
    }
    content += "<br />Pool: " + this.props.data.pool;
    if (this.props.data.warnings) {
        content += "<br /><span class='text-danger'>Warnings:<ul>";
        for (var idx in this.props.data.warnings) {
            var warning = this.props.data.warnings[idx];
            content += "<li>" + warning + "</li>";
        }
        content += "</ul></span>";
    }
    if (this.props.data.reasonForDestruction) {
        content += "<div class='text-danger'>Reason for destruction: " + this.props.data.reasonForDestruction + "</span>";
    }
    return content;
  },
  componentDidMount: function() {
    var content = this.generatePopoverContent();
    $("#node-" + this.props.data.id).popover({
      title: this.props.data.id,
      container: "body",
      content: content,
      trigger: "hover",
      placement: "auto",
      html: true
    });
  },
  render: function() {
    var labelClassNames = "label machine-label " + stateMap[this.props.data.state]["labelClass"];
    var iconClassNames = "glyphicon " + stateMap[this.props.data.state]["iconClass"];
    var warningSign = "";
    if (this.props.data.warnings) {
      warningSign = (<span className="warningSignWrapper">
          <span className="glyphicon glyphicon-warning-sign">{this.props.data.warnings.length}</span>
      </span>)
    }
    return (
      <td className="host machine" id={"node-"+this.props.data.id}>
        <span className={labelClassNames}>
          <span className={iconClassNames}></span>
            {pad(this.props.hostIdx)}
            {warningSign}
        </span>
      </td>
    );
  }
});

var EmptyHostSlot = React.createClass({
  render: function() {
    return (
      <td className="host machine">
        <span className="label-default-light label machine-label">
          <span className="glyphicon glyphicon-ban-circle"></span>
          {pad(this.props.hostIdx)}
        </span>
      </td>
    );
  }
});

var DashboardNav = React.createClass({
  render: function() {
    return (
    <nav className="container navbar navbar-default">
      <ul className="nav navbar-nav">
    {% for dashboardSource in dashboardSources %}
        <li id="navButton_{{ dashboardSource.name }}">
          <a href="#" onClick={ () => this.props.changeDashboardSourceCallback('{{ dashboardSource.name }}') } >
            {{ dashboardSource.name }}
          </a>
        </li>
    {% endfor %}
      </ul>
    </nav> );
  },
});

var initialState = {hosts: [], allocations: []}
var Dashboard = React.createClass({
  render: function() {
    var dashboardContent;
    if (this.state.loadState == "LOADING") {
      dashboardContent = <div className="col-md-6">Loading...</div>;
    } else if (this.state.loadState == "DONE") {
      dashboardContent = <DashboardContent hosts={this.state.hosts} />;
    }
    return (
      <div>
        <DashboardNav changeDashboardSourceCallback={this.loadDashboard} />
        {dashboardContent}
      </div>
    );
  },

  getInitialState: function() {
    return {loadState: "LOADING", hosts: null};
  },

  newStateCallback: function(state) {
    if (state === null) {
      this.forceUpdate();
      return;
    }
    this.setState({loadState: "DONE", hosts: state["hosts"]});
  },

  changeStateToLoading: function(loadState, hosts) {
    this.setState({loadState: "LOADING"});
  },

  loadDashboard: function(dashboardName) {
    this.changeStateToLoading();
    if (activeDashboardName != "") {
        document.getElementById("navButton_" + activeDashboardName).className = "";
        ui.unregister("status_" + activeDashboardName, this.newStateCallback);
    }
    activeDashboardName = "";
    _.each(rackattackInstances, function(instance) {
      if (instance["name"] == dashboardName) {
        activeDashboardHost = instance["host"];
        return;
      }
    }); ui.register("status_" + dashboardName, this.newStateCallback);
    activeDashboardName = dashboardName;
    window.history.pushState("", dashboardName, "/" + dashboardName);
    document.getElementById("navButton_" + dashboardName).className = "active";
  },

  componentDidMount: function() {
    this.loadDefaultDashboard();
  },

  loadDefaultDashboard: function() {
    var defaultDashboard = "{{ defaultDashboard }}";
    if (!defaultDashboard) {
        defaultDashboard = rackattackInstances[0]["name"];
    }
    this.loadDashboard(defaultDashboard);
  }
});

ReactDOM.render(
  <Dashboard />,
  document.getElementById('content')
);
</script>

<main class="container" id="content"></main>

{% endblock %}
